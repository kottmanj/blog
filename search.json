[
  {
    "objectID": "research.html",
    "href": "research.html",
    "title": "research",
    "section": "",
    "text": "My research focuses on developing hybrid quantum algorithms based on physical insight leveraging quantum and classical resources. Those developments are realized within automatized software frameworks so that other researchers can apply, extend, and integrate them into their works.\n\n\n\nHere are three examples focusing on different aspects of variational ground state optimization :\n\nqubits: JCPL 2021 (arxiv:2008.02819)\n\ncircuits: PRA 2022 (arxiv:2105.03836)\n\ngradients: Chemical Science (arxiv:2011.05938)\n\nthrough the tequila library all three developments are automatically available to interested partys\n\nimport tequila tq\n\nmol = tq.Molecule(geometry=\"beh2.xyz\") # uses 1\n\nU = mol.make_ansatz(\"SPA\")             # uses 2\nH = mol.make.hamiltonian()\nE = tq.ExpectationValue(H=H, U=U)\n\nresult = tq.minimize(E)                # uses 3\n\n\nScientific Computing & Software\n\n\n\n\n\nWith high hopes for a powerful future impact on various scientific and industrial applications, the ecosystem of quantum algorithms is proliferating. In the current stage, the field is maturing to a point where it becomes essential to demonstrate new ideas explicitly on actual use cases. The problems often become too complicated for pure theoretical estimates. In addition, one usually deals with a multitude of connected algorithmic procedures and heuristics, rendering manual engineering unfeasible. At this stage, automatized frameworks are crucial to advance further.\nRepresentative publications:\n\nQST 2021 (arxiv:2011.03057): the tequila system\n\nChemical Science (arxiv:2011.05938): automatized and fast gradients for unitary coupled-cluster\n\nBlog entries:\n\ntequila basics\n\ntequila circuits\n\n\n\nApproximations & Intperpretability\n\n\n\n\n An integral part of science is the formulation of abstract concepts capable of capturing the essential aspects of complex processes to keep the concept as simple as possible. Currently, such ideas for the construction of quantum circuits are in high demand. For example, in the context of variational approaches, the design of the circuit determines which states we can reach through variational optimization. It is often the crucial element for success. Interpretable techniques allow us to construct circuits faster and predict their performance more confidently.\nRepresentative publications:\n\narxiv:2207.12421: leverage the concept of chemical graphs\n\nPRA 2022 (arxiv:2105.03836): classically simulable circuits and their integration into a hirarchy of approximations\n\n\n\nMultiresolution Quantum Chemistry\n\n\n\nTraditional electronic structure methods are usually rigid in their numerical representation and rely upon globally pre-defined sets of Gaussian functions whose application requires substantial knowledge if we want to interpret or predict chemical reactions. Multiresolution quantum chemistry offers an alternative where the orbitals are represented by a multiresolution analysis - a recursive decomposition of the spatial one-particle Hilbert space that allows automatic adaptive construction of a scale-invariant spectral element representation. From a user perspective, we can ignore the numerical details. Astonishingly, this often also holds for the development of new applications. I use madness for implementation and integration of the developed methods.\nRepresentative publications:\n\nJCPL 2021 (arxiv:2008.02819): qubit reductions through MRA based PNOs\n\nJCP 2020: numerically exact MP2-PNO with explicit correlation\n\nJCTC 2018: numerically exact CC2 with explicit correlation\n\nBlog entries:\n\nwhat is MRA\n\n\n\nBlack-Box Methods\n\n\n\n\n\nTo render new numerical algorithms or heuristics applicable, it is essential to provide them within a robust and easy-to-use software framework with useful defaults for all internal parameters and thresholds. Ideally, the method can be applied as a black box - meaning the user does not need to bring any knowledge about the underlying details to use the software. In reality, we often can not provide a full black box, but for most methods we can get close. Within my research, I aim to come as close as possible to this ideal. Some developments would not have been possible without this paradigm in the first place.\nRepresentative publications where robust black-box procedures, as illustrated in the code-box on top of this page, were crucial for the demonstration of new ideas:\n\nJCPL 2021 (see above) relies on the implementation of JCP 2020 with itself relies on the automatized construction of suitable guess orbitals implemented in PCCP 2015\n\nPRR 2022: Conceptual work on defining trust-intervals for variational approaches led by Maurice Weber (ETH). We applied our black-box approaches to circuit construction, gradient computation and basis-set-free orbital generation.\n\nQST 2021: Work led by Zi-Jian Zhang (UofT) on prescreening of operator pools for adaptive circuit construction. We applied our black-box approaches to basis-set-free orbital generation.\n\nPCCP 2022: Work led by Philipp Schleich (UofT) on energy corrections with explicit correlation. We applied our black-box approaches to circuit construction, gradient computation and basis-set-free orbital generation."
  },
  {
    "objectID": "posts/mra-basics/index.html",
    "href": "posts/mra-basics/index.html",
    "title": "jsk",
    "section": "",
    "text": "Part 1: A first glimpse with hands-on examples.\n\nLegendre polynomials as basis\nScaling functions\nshifting, rescaling, integration\n\n\n\n\n\n\nIn the following, we will explore how to use Legendre polynomials as a basis for functions in \\({L}^2\\left(\\left[0,1\\right]\\right)\\) - the Hilbertspace of square-integrable functions on the interval \\([0,1]\\). From this, it is only a minor step to represent functions on an arbitrary interval \\([a,b]\\) by shifting and rescaling and a bit more technical development for hypercubes \\([a,b]^d\\).\nWithin my (research)[research.qmd], I often use MRA to describe electronic wavefunctions such as orbitals (\\(f \\in L^2\\left(\\left[a,b\\right]^3\\right)\\) - see for example here) and pair functions (\\(f \\in L^2\\left(\\left[a,b\\right]^3\\right)\\) - see for example here). In this context, my MRA codebase of choice is madness - a high-performance c++ library. In this post, we will, however, use simple python code to illustrate the basic principles of an MRA representation.\n\n\nThe Legendre polynomials \\(P_k(x)\\) are a system of orthogonal and complete functions on \\([-1,1]\\). Hence, we can use them as a basis on \\([0,1]\\) and approximate any function on that interval as a linear combination of a finite subset \\(P_k\\).\nTo be consistent with some of the literature listed below, we will rescale the polynomials to the unit interval \\[\n\\tilde{P}_k(x) = \\sqrt{2k+1} P_k\\left(2x-1\\right)\n\\] where the prefactor ensures normalization. We can define this as small class in python code:\n\nimport numpy\nimport scipy\n\nclass LegendreBasisFunction:\n\n    def __init__(self, k, *args, **kwargs):\n        self.k = k\n\n    def __call__(self, x, *args, **kwargs):\n        x = 2*x-1\n        N = numpy.sqrt((2.0*self.k+1.0))\n        return N*scipy.special.legendre(n=self.k)(x)\n\nAll that is left know to approximate a function \\(f \\in L^2\\left(\\left[0,1\\right]\\right)\\) as \\[\nf \\approx \\sum_k c_l \\tilde{P}_l(x) \\quad c_l = \\int_0^1 f(x)P_l(x) \\operatorname{d}x\n\\] is to compute the coefficients \\(c_k\\).\n\n\n\nWhen using the polynomials as basis it is convenient to employ Gauss-Legendre quadrature for integration \\[\n\\langle f \\vert g \\rangle = \\int_0^1 f(x)g(x) \\operatorname{d}x  \\approx \\sum_i wᵢ f(xᵢ)g(xᵢ)\n\\] where wᵢ and xᵢ are the points and wheights of the quadrature (we can conveniently import them from scipy). In code this looks like:\n\ndef integrate(f,order,a=0,b=1, verbose=False):\n    \"\"\"\n    integrate in interval [a,b] subset to [0,1]\n    \"\"\"\n    x, w = scipy.special.roots_legendre(n=order+1)\n    \n    # change of interval\n    x = (b-a)/2*x + (a+b)/2\n    N = (b-a)/2\n    y = N*f(x)\n    return numpy.sum(w*y)\n\n# convenient for inner product integrals\ndef inner(f,g,order,a=0,b=1):\n    return integrate(lambda x: f(x)*g(x), order=order, a=a, b=b)\n\nwhere we already included the quadrature on arbitrary intervals \\([a,b]\\).\nLet’s test if everything works by checking orthonormality of our basis\n\n\nCode\nkmax = 5\nout = \"\"\nfor k1 in range(kmax):\n    f1 = LegendreBasisFunction(k=k1)\n    for k2 in range(k1+1):\n        f2 = LegendreBasisFunction(k=k2)\n        ip = inner(f1,f2,order=max(k1,k2))\n        out += \"{:+2.3f}\".format(ip)\n    out += \"\\n\"\n\nprint(out)\n\n\n+1.000\n+0.000+1.000\n+0.000+0.000+1.000\n-0.000-0.000-0.000+1.000\n-0.000-0.000-0.000-0.000+1.000\n\n\n\nLooks good so far!\n\n\n\nLet’s represent some function with the Polynomial basis we have constructed above. We will use the function \\[\nf(x) = \\sin\\left( e^{-3.0*\\left(2x-1\\right)} \\right)\\frac{\\sin\\left(2x-1\\right)}{2x-1}.\n\\] It looks like\n\n\nCode\ndef f(x):\n    x = 2*x-1\n    a= numpy.exp(-10*(x+0.5)**2)\n    b= numpy.sinc(x)\n    return numpy.sin(numpy.exp(-3.0*(x)))*b\n\nimport matplotlib.pyplot as plt\nx = numpy.linspace(0.0,1.0,500)\nfx = f(x)\nplt.plot(x,fx, color=\"navy\")\nplt.show()\n\n\n\n\n\nWe can create the function in the basis of our rescaled Legendre Polynomials up to order \\(k\\) as \\[\nf(x) = \\sum_{l=1}^{k} c_l \\tilde{P}_l(x), \\quad c_l = \\langle f  \\vert \\tilde{P}_l \\rangle.\n\\] and compute the coefficients with our Gauss-Legendre integration function defined above.\nWe will do this by defining the class ProjectedFunction\n\nclass ProjectedFunction:\n\n    def __init__(self, f, k=1):\n        assert k>0\n        self.k = k\n\n        # initialize basis functions\n        self.basis = [LegendreBasisFunction(k=kk) for kk in range(k)]\n\n        # compute the coefficients in the legedre basis\n        # by computing the integral via Gauss-Legedre Quadrature\n        self.coeffs = [inner(f,self.basis[n],order=k) for n in range(k)]\n\n    def __call__(self, x, *args, **kwargs):\n        y = [self.coeffs[n]*self.basis[n](x) for n in range(self.k)]\n        return sum(y)\n\nThis class projects a given function f onto the basis spanned by \\(P_l(x)\\) with \\(l\\leq k\\) - more formally we have an implementation of \\[\n\\text{span}\\left\\{ \\tilde{P}_l \\right\\}_{l=1}^{k} \\subset {L}^2\\left(\\left[0,1\\right]\\right).\n\\]\nThrough the __call__ operator we can use initialized objects of ProjectedFunction just like regular functions.\n\nF = ProjectedFunction(f, k=5)\ny = F(1.0)\n\nLet’s see how our example function above looks like on different orders \\(k\\):\n\n\nCode\n# x and y defined before\nplt.plot(x,fx, color=\"navy\")\n\ncolor = [\"forestgreen\", \"tab:blue\", \"tab:orange\", \"tab:red\"]\nfor i,k in enumerate([5,10,20,40]):\n    F = ProjectedFunction(f, k=k)\n    plt.plot(x,F(x), color=color[i], linestyle=\"--\", label=\"k={}\".format(k))\n\nplt.legend()\nplt.show()"
  },
  {
    "objectID": "posts/tq-circuits/index.html",
    "href": "posts/tq-circuits/index.html",
    "title": "Tequila Basics: Circuits",
    "section": "",
    "text": "A brief introduction to tequila circuits"
  },
  {
    "objectID": "posts/tq-circuits/index.html#add-controls",
    "href": "posts/tq-circuits/index.html#add-controls",
    "title": "Tequila Basics: Circuits",
    "section": "Add Controls",
    "text": "Add Controls\nYou can take one circuit and add control-options to it\n\ncU = U.add_controls([3,4])\n\n\n\n\noriginal\n\n\n\n\n\nadded controls"
  },
  {
    "objectID": "posts/tq-circuits/index.html#re-parametrize",
    "href": "posts/tq-circuits/index.html#re-parametrize",
    "title": "Tequila Basics: Circuits",
    "section": "Re-Parametrize",
    "text": "Re-Parametrize\n\nUX = U.map_variables({\"a\":\"b\"})\nUY = UX.map_variables({\"b\":1.0})\nprint(\"angles in U :\",U.extract_variables())\nprint(\"angles in UX:\",UX.extract_variables())\nprint(\"angles in UY:\",UY.extract_variables())\n\nangles in U : [a]\nangles in UX: [b]\nangles in UY: []"
  },
  {
    "objectID": "posts/tq-circuits/index.html#map-qubits",
    "href": "posts/tq-circuits/index.html#map-qubits",
    "title": "Tequila Basics: Circuits",
    "section": "Map-Qubits",
    "text": "Map-Qubits\n\nUZ = U.map_qubits({0:1,1:2}) \nprint(UZ)\n\ncircuit: \nRy(target=(1,), parameter=f([a]))\nX(target=(2,), control=(1,))"
  },
  {
    "objectID": "posts/tq-circuits/index.html#decompose-gates",
    "href": "posts/tq-circuits/index.html#decompose-gates",
    "title": "Tequila Basics: Circuits",
    "section": "Decompose Gates",
    "text": "Decompose Gates\nTequila can decompose gates automatically (e.g. for differentiation or translation to backend), you can however also do this manually with tq.compile_circuit. The default compiles down to the lowest lever (only standard single qubit gates and controlled-nots). You can specifiy the compile options with keywords like controlled_rotation=False. See here for all keywords.\n\nU1 = tq.gates.H(0)\nU1+= tq.gates.Ry(\"a\",0,control=1) \nU1+= tq.gates.ExpPauli(angle=\"b\", paulistring=\"X(0)X(2)\")\n# let's compile to different levels\nU2 = tq.compile_circuit(U1)\nU3 = tq.compile_circuit(U1, controlled_rotation=False)\nU4 = tq.compile_circuit(U1, exponential_pauli=False)\n\nthe four circuits are\n\n\n\nU1\n\n\n\n\n\nU2 (full compile)\n\n\n\n\n\nU3 (conrolled_rotation=False)\n\n\n\n\n\nU4 (exponential_pauli=False)"
  },
  {
    "objectID": "posts/tq-circuits/index.html#get-generators",
    "href": "posts/tq-circuits/index.html#get-generators",
    "title": "Tequila Basics: Circuits",
    "section": "Get Generators",
    "text": "Get Generators\nThe generators of individual gates can be constructed with the make_generator function. Here we can include the control qubits in the definition of the generator. Take for example\n\nU = tq.gates.Ry(angle=\"a\", target=0) + tq.gates.X(control=0, target=1) \nfor gate in U.gates:\n    generator = gate.make_generator()\n    print(\"gate generated by:\", generator)\n    if gate.is_controlled():\n        cgenerator = gate.make_generator(include_controls=True)\n        print(\"including control qubits:\", cgenerator)\n\ngate generated by: +1.0000Y(0)\ngate generated by: +1.0000X(1)-1.0000\nincluding control qubits: +0.5000X(1)-0.5000-0.5000Z(0)X(1)+0.5000Z(0)"
  },
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Hello Quarto World",
    "section": "",
    "text": "Welcome to this blog.\nMy friend and former co-worker Kjell introduced me to quarto - a publishing system for scientific and technical content. It is quite amazing and I pledge to make good use of it in the near future.\nIf you are thinking about using quarto yourself, I recommend their online guide. The guide for blogs is for example here. The source files for this blog can be found here, they might be useful in creating your own blog."
  },
  {
    "objectID": "posts/tq-get-started/index.html",
    "href": "posts/tq-get-started/index.html",
    "title": "Tequila Basics: Getting Started",
    "section": "",
    "text": "Create some abstract quantum functions with tequila"
  },
  {
    "objectID": "posts/tq-get-started/index.html#installation",
    "href": "posts/tq-get-started/index.html#installation",
    "title": "Tequila Basics: Getting Started",
    "section": "Installation",
    "text": "Installation\nif you are on Linux or Mac, you can install tequila directly from the PyPi cloud via\npip install tequila-basic\nthis installs you the tequila package with only the absolutely necessary dependencies.\nUsing windows as an operating systems will lead to errors here as the jax library is not supported.\nIn the future there will be a separate blog entry for windows users, meanwhile see the github readme.\nNot necessary but recommended it the installation of a capable simulator for you quantum circuits. Tequila supports the usual suspects, the by far fastest option is however the qualcs simulator that can conveniently be installed as\npip install qulacs"
  },
  {
    "objectID": "posts/tq-get-started/index.html#define-an-expectation-value",
    "href": "posts/tq-get-started/index.html#define-an-expectation-value",
    "title": "Tequila Basics: Getting Started",
    "section": "Define an Expectation Value",
    "text": "Define an Expectation Value\nAn expectation value \\(E = \\langle H \\rangle_U\\) consists of two parts: 1. a quantum circuit U (a unitary operation expressed as a sequence of unitaries) that defines the wavefunction 2. a qubit Hamiltonian H (an hermitian operator exporessed in Pauli-strings)\nhere is a small example with the Hamiltonian \\[ H = X(0)X(1) + \\frac{1}{2} Z(0)Z(1) \\] and the quantum circuit\n\n\n\n\n\nimport tequila as tq\n\nH = tq.paulis.X([0,1]) + 0.5*tq.paulis.Z([0,1])\nU = tq.gates.Ry(\"a\", 0) + tq.gates.X(1,control=0)\nE = tq.ExpectationValue(H=H, U=U)\n\nnote that we have parametrized one of the gates (marked in pink), so that our expectation value becomes a function of this paramteter \\[E=f(a).\\]"
  },
  {
    "objectID": "posts/tq-get-started/index.html#evaluate-the-expectation-value",
    "href": "posts/tq-get-started/index.html#evaluate-the-expectation-value",
    "title": "Tequila Basics: Getting Started",
    "section": "Evaluate the Expectation Value",
    "text": "Evaluate the Expectation Value\nWe can evaluate the expectation value by compiling it to a backend (a simulator or interface to some quantum hardware)\n\nf = tq.compile(E)\nevaluated = f({\"a\":1.0})\nprint(\"f(1.0) = {:+2.4f}\".format(evaluated))\n\nf(1.0) = +1.3415\n\n\nif you have installed qulacs before then tq.compile translated the underlying objects to qulacs. Otherwise another simulator on your system, or the horrible tequila debug simulator was used. You can figure out which simulators you have installed by calling tq.show_available_simualtors. When passing backend=\"qulacs\" to tq.compile you can speficy which backend you want to compile to.\nIf ever in doubt if the current object is already compiled, just print it\n\nprint(\"abstract expectation value is:\")\nprint(E)\nprint(\"compiled function is:\")\nprint(f)\n\nabstract expectation value is:\nObjective with 1 unique expectation values\ntotal measurements = 2\nvariables          = [a]\ntypes              = not compiled\ncompiled function is:\nObjective with 1 unique expectation values\ntotal measurements = 2\nvariables          = [a]\ntypes              = [<class 'tequila.simulators.simulator_qulacs.BackendExpectationValueQulacs'>]\n\n\nThe printput states that our objects are tq.Objectives with a given number of unique expectation values. More about this now."
  },
  {
    "objectID": "posts/tq-get-started/index.html#differentiate-and-manipulate-expectation-values",
    "href": "posts/tq-get-started/index.html#differentiate-and-manipulate-expectation-values",
    "title": "Tequila Basics: Getting Started",
    "section": "Differentiate and Manipulate Expectation Values",
    "text": "Differentiate and Manipulate Expectation Values\nThe expecation value can be used to define more complicated objects. Here are some examples:\nThe gradient \\[ \\frac{\\partial }{\\partial a } E(a) \\] with respect to variable a can be computed as\n\ndE = tq.grad(E,\"a\")\nprint(dE)\n\nObjective with 2 unique expectation values\ntotal measurements = 4\nvariables          = [a]\ntypes              = not compiled\n\n\nand the corresponding object can then be compiled and evaluated in the same way\n\ndf = tq.compile(dE)\nevaluated = df({\"a\":1.0})\nprint(\"df/da(1.0 = {:+2.4f}\".format(evaluated))\n\ndf/da(1.0 = +0.5403\n\n\napart from differentiating we can also combine the tq.Objective objects. The final example illustrates most of these possibilities."
  },
  {
    "objectID": "posts/tq-get-started/index.html#example",
    "href": "posts/tq-get-started/index.html#example",
    "title": "Tequila Basics: Getting Started",
    "section": "Example",
    "text": "Example\nLet’s create the function \\[ L(a) = \\frac{\\partial E}{\\partial a}(a) E(a)^3 + e^{-\\left(\\frac{\\partial E }{\\partial a}(a) \\right)^2} \\]\n\nL = E**3*dE +  (-dE**2).apply(tq.numpy.exp)\nl = tq.compile(L)\n\nand now let’s have a look how this function and it’s gradient \\(\\frac{\\partial L}{\\partial a}\\) looks like\n\n\nCode\nimport numpy\nimport matplotlib.pyplot as plt\n\n# get the abstract gradient and compile\ndL = tq.grad(L, \"a\")\ndl = tq.compile(dL)\n\nx = list(numpy.linspace(-numpy.pi, numpy.pi, 100))\ny0 = [ l({\"a\":xx}) for xx in x]\ny1 = [ dl({\"a\":xx}) for xx in x]\nplt.plot(x,y0, label=\"$L(a)$\", color=\"navy\")\nplt.plot(x,y1, label=r\"$\\frac{\\partial L}{\\partial a}(a)$\", color=\"tab:red\")\nplt.legend()\nplt.savefig(\"fig.png\")\nplt.show()"
  },
  {
    "objectID": "posts/mol-circuits/index.html",
    "href": "posts/mol-circuits/index.html",
    "title": "Molecular Quantum Circuits in a Nutshell",
    "section": "",
    "text": "Physical insights into the construction of quantum circuits.\nChemical graphs are a powerful abstraction concept, that enables chemists to derive chemical properties or even estimate possible reactions from a remarkably simple structure. Applied to the design of quantum circuits for electronic ground states (the ground states of molecules), chemical graphs allow physical insight into construction, optimization, and interpretation of quantum circuits.\nA detailed description of this methodology is given in arxiv:2207.12421 (recently published in Quantum). In this blog entry we will try to approach this circuit design principle through an explicit example. We will use tequila, which has been introduced in other blog entries"
  },
  {
    "objectID": "posts/mol-circuits/index.html#basic-building-blocks",
    "href": "posts/mol-circuits/index.html#basic-building-blocks",
    "title": "Molecular Quantum Circuits in a Nutshell",
    "section": "Basic Building Blocks",
    "text": "Basic Building Blocks\nIn conventional methodologies of (unitary) coupled-cluster, the wavefunction is generated by exciting electrons from an initial basis state containing a specific number of electrons. A significant distinction between traditional coupled cluster (both unitary and non-unitary) and recent advancements in quantum circuit design lies in the exclusion of higher-order excitations. Instead, the focus is on utilizing a limited set of unitary operations, which are subsequently iteratively applied in a layer-by-layer manner.\nWithin conventional coupled-cluster approaches, a particular type of excitation, such as a single-electron excitation between two orbitals, is typically accounted for only once. To enhance accuracy, higher-order excitations are introduced.\nHowever, in the context of quantum circuit designs, like the one being discussed, this specific excitation might occur multiple times in various sections of the circuit, while the inclusion of higher-order excitations is often bypassed or minimized.\nA simple choice of two basic building blocks for electronic quantum circuits are:\n\nOrbital Rotations (single electron excitations)\n\nPair Excitations (restricted double excitations)\n\nthese operations are for example used in the prominent k-UpCCGSD approach or the separable pair approximation.\nTake for example two orbitals \\(\\phi_0\\) and \\(\\phi_1\\) encoded into four qubits (\\(\\phi_0^\\uparrow,\\phi_0^\\downarrow,\\phi_1^\\uparrow,\\phi_1^\\downarrow\\)) indicating the occupation of the corresponding spin-orbital. The qubit state holding a spin-paired electron pair in orbital \\(\\phi_0\\) is then \\[\n\\lvert 1100 \\rangle.\n\\] If treated as a quasiparticle, the only allowed excitation is \\[\n\\lvert 1100 \\rangle \\rightarrow \\lvert 0011 \\rangle.\n\\] We can treat the spin-paired electrons bound to the same orbital as a quasi-particle – so-called Hard-core Bosons. A wavefunction constructed from Hard-core Boson states entirely is not invariant to rotations in the underlying orbital basis, as we are confining the spin-paired electrons to occupy a specific choice of orbitals. Graphically we can depict this as\n\n\n\nwhere we have shown the situation in a hydrogen molecule in a minimal basis – one atomic orbital on each hydrogen atom. In this case, the rotation into a different orbital basis clearly leads to a different wavefunction.\nWithin quantum circuits, we can rotate the orbital basis with the second building block: the orbital rotations. Here the molecular graph will guide as in placing and initializing the orbital rotation gates within the quantum circuit."
  },
  {
    "objectID": "posts/mol-circuits/index.html#example",
    "href": "posts/mol-circuits/index.html#example",
    "title": "Molecular Quantum Circuits in a Nutshell",
    "section": "Example",
    "text": "Example\nIn the article the linear H4 system has been used to illustrate the construction of quantum circuits from chemical graphs. We will use the H4 example from the paper and provide the code that reproduces it. First we initialize the molecule and represent the Hamiltonian in a minimal basis. Note that we are using (orthonormalized) atomic orbitals as our second quantized basis and not canonical Hartree-Fock orbitals.\n\nimport tequila as tq\nfrom numpy import pi, eye\n\ngeometry = \"\"\"\nH 0.0 0.0 0.0\nH 0.0 0.0 1.5\nH 0.0 0.0 3.0\nH 0.0 0.0 4.5\n\"\"\"\n\nmol = tq.Molecule(geometry=geometry, basis_set=\"sto-3g\")\n# switch to native orbitals\n# in this case: orthonormalized sto-3g orbitals\nmol = mol.use_native_orbitals()\nH = mol.make_hamiltonian()\nexact = mol.compute_energy(\"fci\")\n\nAs initial state we can construct an SPA circuit using the first graph in the figure above. In this first graph, the H\\(_4\\) molecule is interpreted as two H\\(_2\\) molecules. We initializing the graph, by assigning basis orbitals to the vertices. Here we have 4 basis orbitals (atomic s-type orbitals located on the individual atoms), so the assignment is straightforward.\n\n# graph is\n# H--H  H--H\ngraph = [(0,1),(2,3)]\nUSPA = mol.make_ansatz(name=\"SPA\", edges=graph)\nESPA = tq.ExpectationValue(H=H, U=USPA)\nresult = tq.minimize(ESPA, silent=True)\n\nprint(\"SPA/Atomic error: {:+2.5f}\".format(result.energy-exact))\n\nSPA/Atomic error: +1.09885\n\n\nwe see, that the SPA does not perform well – the reason is that we are currently in an atomic orbital basis. In order to rotate the basis, we add orbital rotations to the initial circuit. Here we will use a static angle that will mix the orbitals in a equally weighted fashion (corresponding to Eq.19 in the article, here explicitly represented with unitary circuits). This represents the SPA in a basis that would correspond to the optimized setting in two isolated H2 molecules (i.e. the first graph)\n\nUR0 = tq.QCircuit()\nfor edge in graph:\n    UR0 += mol.UR(edge[0],edge[1],angle=pi/2)\n\nU0 = USPA + UR0\nE0 = tq.ExpectationValue(H=H, U=U0)\nresult = tq.minimize(E0, silent=True)\n\nprint(\"SPA/Molecular error: {:+2.5f}\".format(result.energy-exact))\n\nSPA/Molecular error: +0.04009\n\n\nThe error is now 40 millihartree. We can bring it further down by allowing the orbitals to relax which can be achieved by adding more orbital rotations with variable angles. We initialize the angles to zero (i.e. we are starting from our previous result as guess). We chose the same pattern as in the \\(U_\\text{RR}\\) circuits in the article\n\n\nCode\nURR0 = mol.UR(0,1,angle=\"b\")\nURR0 = mol.UR(2,3,angle=\"b\")\nURR0 = mol.UR(1,2,angle=\"a\")\n\nU0 = USPA + URR0 + UR0 + URR0 \nE0 = tq.ExpectationValue(H=H, U=U0)\nresult = tq.minimize(E0, silent=True, initial_values=result.variables)\n\nprint(\"SPA/Relaxed-Molecular error: {:+2.5f}\".format(result.energy-exact))\n\n\nSPA/Relaxed-Molecular error: +0.03560\n\n\nAlternatively we can optimize the orbitals with respect to the SPA wavefunction (the strategy from the article) and use this as our orbital basis. As the SPA wavefunction is entirelty within the Hardcode-boson quasiparticle approximation, we can perform the optimization within that approximation reducing our simulation time significantly (see code in the article for the equivalent optimization without HCB approximation)\n\n\nCode\nUHCB = mol.make_ansatz(name=\"HCB-SPA\", edges=graph)\nguess = eye(4)\nguess[0] = [1, 1,0, 0]\nguess[0] = [1,-1,0, 0]\nguess[0] = [0, 0,1, 1]\nguess[0] = [0, 0,1,-1]\nopt = tq.chemistry.optimize_orbitals(circuit=UHCB,molecule=mol, use_hcb=True, initial_guess=guess.T, silent=True)\n\n# update our Hamiltonian\nmol = opt.molecule\nH = mol.make_hamiltonian()\n\nUSPA = UHCB + mol.hcb_to_me()\nE = tq.ExpectationValue(H=H, U=USPA)\nresult = tq.minimize(E, silent=True)\n\nprint(\"SPA/opt-orbitals error: {:+2.5f}\".format(result.energy-exact))\n\n\nSPA/opt-orbitals error: +0.01626\n\n\nNote, that we can get the same result by providing enough orbital rotations to our circuit.\nTo improve on the SPA model in the optimal basis we take the second graph and apply the following pattern \\[\nU_G = U_R^\\dagger U_C U_R\n\\] that corresponds to 1. rotate into a new orbital basis that resembles the graph structure 2. correlate the quasi particles in this orbital basis 3. rotate back\nIn the following we will do this for the H4 system using the two graphs indicated in the picture above. The first graph is used for the SPA initalization, and the second graph will add further correlation to the initial SPA state. Note that we included an approximation by neglecting one edge in the second graph which we will not correlated. The code-block is identical as the on in the appendix of the article.\n\n\nCode\n# dependencies: tequila >= 1.8.7, pyscf~=1.7, scipy~=1.7\n# suggested quantum backend for optimal performance: qulacs >= 0.3\nimport tequila as tq\nfrom numpy import eye, pi\n\n# Create the molecule object\n# use orthonormalized atomic orbitals as basis\ngeometry = \"h 0.0 0.0 0.0\\nh 0.0 0.0 1.5\\nh 0.0 0.0 3.0\\nh 0.0 0.0 4.5\"\nmol = tq.Molecule(geometry=geometry, basis_set=\"sto-3g\")\nenergies = {\"FCI\":mol.compute_energy(\"fci\")}\n# switch from canonical HF orbitals to orthonormalized STO-3G orbitals\n# to follow notation in the article\nmol = mol.use_native_orbitals()\n\n# Create the SPA circuit for\n# Graph: H -- H    H -- H\n# edges get tuples of orbital-indices assigned\nUSPA = mol.make_ansatz(name=\"SPA\", edges=[(0,1),(2,3)])\n\n# initial guess for the orbitals\n# according to graph in Eq.(17) and orbitals in Eq.(19)\nguess = eye(4)\nguess[0] = [1.0,1.0,0.0,0.0]\nguess[1] = [1.0,-1.,0.0,0.0]\nguess[2] = [0.0,0.0,1.0,1.0]\nguess[3] = [0.0,0.0,1.0,-1.]\n\n# optimize orbitals and circuit parameter\n# PySCF interface\nopt = tq.chemistry.optimize_orbitals(mol, circuit=USPA, initial_guess=guess.T)\nprint(\"Optimized Orbital Coefficients\")\nprint(opt.molecule.integral_manager.orbital_coefficients)\nenergies[\"SPA\"] = opt.energy\n\n# get Hamiltonian with optimized orbitals\nH = opt.molecule.make_hamiltonian()\n\n# initialize rotations to graph in Eq.(21)\n# H    H -- H    H\n# as illustrated in Eq.(24)\n# UR as in Eq.(7) uses spatial orbital indices\nR0 = tq.Variable(\"R0\")\nR1 = tq.Variable(\"R1\")\nUR0 = mol.UR(0,1,angle=(R0+0.5)*pi)\nUR0+= mol.UR(2,3,angle=(R0+0.5)*pi)\nUR1 = mol.UR(1,2,angle=(R1+0.5)*pi)\n\n# initialize correlator according to Eq.(22)\nUC = mol.UC(1,2,angle=\"C\")\n\n# construct the circuit for both graphs\nU = USPA + UR0 + UR1 + UC + UR1.dagger() + UR0.dagger()\n# optimize the energy\nE = tq.ExpectationValue(H=H, U=U)\nresult = tq.minimize(E, silent=True)\nenergies[\"SPA+\"] = result.energy\nprint(energies)\n\n\n\n\nCode\nfor k,v in energies.items():\n    if \"fci\" in k.lower(): continue\n    print(\"{:5} error : {:+2.5f}\".format(k,v-exact))\n\n\nSPA   error : +0.01626\nSPA+  error : +0.00844"
  },
  {
    "objectID": "posts/mol-circuits/index.html#dependencies-and-installation",
    "href": "posts/mol-circuits/index.html#dependencies-and-installation",
    "title": "Molecular Quantum Circuits in a Nutshell",
    "section": "Dependencies and Installation",
    "text": "Dependencies and Installation\nIn order to execute code from this blog entry you need the following dependencies in your environment\npip install tequila-basic\npip install pyscf\n# optional (significantly faster)\npip install qulacs"
  },
  {
    "objectID": "posts/electronic-hamiltonians/index.html",
    "href": "posts/electronic-hamiltonians/index.html",
    "title": "Electronic Hamiltonians",
    "section": "",
    "text": "What are electronic Hamiltonians and how can we construct them?\n\n\n\n\n\nFirst Quantized Formulation:\n\nHamiltonian is directly defined from the nuclear coordinates and charges\n\nSpin and Fermionic anti-symmetry need to be imposed on the wavefunctions\n\nParticle number is fixed\n\nExplicit computation of matrix representation unfeasible without approximations\n\nSecond Quantized Formulation:\n\nNeeds a set of orbitals to be constructed\n\nSpin and Fermionic anti-symmetry included in Hamiltonian\n\nParticle number is not fixed\n\nExplicit construction in finite basis feasible\n\n\n\n\nThe word molecule often stands for \\(N_\\text{e}\\) electrons with coordinates \\(r_k\\) moving in a potential created by atomic nuclei - assumed to be fixed point-charges with coordinates \\(R_A\\) and charges \\(N_A\\). The electronic Hamiltonian is then the operator expressing the interactions of the electrons in that potential \\[H =  \\sum_{k}^{N_\\text{e}} h\\left(r_k\\right) + \\sum_{k}^{N_\\text{e}} \\sum_{l<k} g\\left(r_k,r_l\\right) + V_\\text{nn}.\\] We write it three parts and a constant, which are in atomic units:\n\nOne-body interactions: \\[ h(r) = T(r) + V_\\text{ne}(r) \\] including the kinetic energy of the electrons and the Coulombic attraction between electrons and nuclear charges\n\\[T(r) = -\\frac{1}{2} {\\nabla^2_{r}}, \\quad V_{\\text{ne}}(r) = \\sum_{A \\in \\text{nuclei}} \\frac{N_A}{\\|r-R_A\\|}.\\]\n\nTwo-body interactions: the Coulombic repulsion between individual electrons\n\\[g(r_k,r_l) = \\frac{1}{\\| r_k - r_l \\|}\\]\n\nA constant term: Coulombic repulsion between the nuclear charges\n\\[V_\\text{nn} = \\sum_{A<B} \\frac{N_A N_B}{\\|R_A - R_b\\|} \\]\nwhich is just a constant for a given molecular structure.\n\nWith this, we have fully defined it, and the lowest eigenvalue of this differential operator gives the corresponding ground state energy. To ensure that the ground state describes a multi-electron system, we must impose restrictions on the wavefunction - Fermions have a spin and anti-symmetric permutation symmetry.\n\n\nAs we are describing electrons, they need to obey fermionic antisymmetry. In first quantization (or real-space formulation), the Hamiltonian does not have that property included, so without restrictions on the wavefunctions, it only describes \\(N_\\text{e}\\) negatively charged point-particles without any permutation symmetries or spin.\nWe can add spin conveniently by defining a single-electron wavefunction as a so called spin-orbital: A three-dimensional function \\(\\psi(r) \\in \\mathcal{L}^2(\\mathbb{R}^3)\\), describing the electron in spatial space, augmented with a spin-state \\[\\lvert\\sigma\\rangle \\in \\text{Span}\\left\\{\\lvert \\uparrow \\rangle, \\lvert \\downarrow \\rangle\\right\\} \\equiv \\mathbb{C}^2.\\] If the set of spatial orbitals \\(\\psi_k\\) forms a complete basis in \\(\\mathcal{L}^2(\\mathbb{R}^3)\\), we have an exact description of the electron. A convenient notation is to express the spin component as a function of a spin-coordinate \\(s\\left\\{-1,1\\right\\}\\) and combine spin coordinate \\(s\\) and spatial coordinate \\(r\\) to \\(x=(r,s)\\). In a given set of \\(M\\) spatial orbital, an arbitrary one electron wavefunction can then be expressed as \\[\n\\Psi(x) = \\sum_k^{2M} c_k \\phi(x) = \\sum_{l}^{M} \\psi_{l}(r)\\otimes \\left( c_{2l}\\lvert \\uparrow \\rangle + c_{2l+1} \\lvert \\downarrow \\rangle \\right)\n\\] with the spin-orbitals defined as \\[\n\\phi_k = \\psi_{\\lfloor{i/2}\\rfloor} \\otimes \\lvert \\sigma(k) \\rangle,\\; \\sigma_k=\\begin{cases} \\lvert \\uparrow \\rangle,\\; k \\text{ is even}  \\\\  \\lvert \\uparrow \\rangle,\\; k \\text{ is odd}  \\end{cases}.  \n\\] Many electron functions can then be constructed as linear combinations of anti-symmetric products of single electron functions (so called Slater-Determinants). \\[\n\\Psi\\left(x_1, \\dots, x_{N_\\text{e}}\\right) = \\sum_{m} d_m \\det\\left(\\phi_{m_1},\\dots, \\phi_{m_{N_\\text{e}}}\\right) \\\n\\]\n\n\n\n\nUsing second quantized language, we can significantly simplify the treatment of electron spin and anti-symmetry with the help of abstract field operators \\(\\hat{\\phi}^\\dagger(x)\\) (\\(\\hat{\\phi}(x)\\)) that create (or annihilate) electrons at spin-position \\(x\\). With them, we can formaly write the electronic Hamiltonian as \\[H = \\int \\hat{\\phi}^\\dagger(x) h(x) \\hat{\\phi}(x) \\operatorname{x}x + \\int \\int \\hat{\\phi}^\\dagger(x)\\hat{\\phi}^\\dagger(y) g(x,y) \\hat{\\phi}(x)\\hat{\\phi}(y) \\operatorname{d}x\\operatorname{d}y+ V_\\text{nn}.\\] The wavefunction is now only required to carry information about electron occupancies at all points in space. When acting on the wavefunction, the one-body part of the operator is first annihilating an electron at point \\(x\\). If no electron is present, this will lead to an energy contribution of zero and otherwise invoke \\(h(x)\\), followed by the restoration of the electron by the creation operator. The two-body part acts in the same way and the integrals ensure that we probe all points in space. In practice, this is unfeasible, and it is convenient to introduce a finite basis in the form of spin orbitals to expand the field operators as \\[\\hat{\\phi}(x) = \\sum_k \\phi(x)_k a_k, \\] leading to the more prominent form of the second quantized Hamiltonian \\[\nH = \\sum_{ij} \\tilde{h}^i{j}a^\\dagger_i a_j \\sum_{ijkl} \\tilde{g}^{ij}_{kl} a^\\dagger_i a^\\dagger_j a_l a_k + V_\\text{nn}.\n\\] The new discretized operators \\(a^\\dagger_k\\) (\\(a_k\\)) are now creating (annihilating) an electron in the spin orbital \\(\\phi_k\\) and the tensors \\(\\tilde{h}^{i}_{j}\\) and \\(\\tilde{g}^{ij}_{kl}\\) are integrals over the one- and two-body operators and the spin orbitals. The one-body integrals are then given by \\[\n\\tilde{h}^{i}_{j} = h^{\\lfloor{i/2}\\rfloor}_{\\lfloor{j/2}\\rfloor} \\langle \\sigma_i \\vert \\sigma_j  \\rangle\n\\] with the spatial part \\[ h^{k}_{l} =  \\langle k \\rvert h \\lvert l \\rangle \\equiv \\int \\psi_k^*(r) h(r) \\psi_l(r) \\operatorname{d}r. \\] In the same way, the spatial part of the two-body integrals is given by \\[ g^{ij}_{kl} = \\langle i j \\rvert g_{12}  \\lvert k l \\rangle \\equiv \\int \\int \\psi_i^*(r_1) \\psi_j^*(r_2) \\frac{1}{|r_1-r_2|} \\psi_k(r_1) \\psi_l(r_2) \\operatorname{d}r_1 \\operatorname{d}r_2.  \\] Note that there exist three different short notations \\[ \\langle ij\\vert kl \\rangle \\equiv \\left(ik \\vert jl \\right) \\equiv \\left[ ij  \\vert lk \\right]  \\] usually referred to as Dirac (physicist, 1212), Mulliken (chemist, 1122) and openfermion (google, 1221) notations. Depending on the convention used, the meaning of the indices \\(g^{ij}_{kl}\\) changes. This is a bit inconvenient, but we can’t change it anymore. Most quantum chemistry packages (pyscf, psi4) use the Mulliken convention, some quantum computing packages adopted the google convention, and the Dirac convention is often found in articles. In the tequila package we tried to automatize most of it away for user convenience. Here is a small example on how to get the integrals using tequila (with either pyscf or psi4 in the back):\n\nimport tequila as tq\n\ngeometry = \"Be 0.0 0.0 0.0\"\nmol = tq.Molecule(geometry=geometry, basis_set=\"6-31G\")\n\nc,h,g = mol.get_integrals(two_body_oderings=\"mulliken\")\n\nconverged SCF energy = -14.5667640335096\n\n\nfor most applications, the integrals are however processed automatically in the back.\n\n\n\nLet’s look at first and second quantized Hamiltonians and wavefunctions in an explicit example: The Helium atom (charge \\(N_\\text{He}=2\\) and nuclear coordinate \\(R_\\text{He} = (0,0,0)\\)) in a basis of two spatial orbitals \\(\\left\\{\\psi_0, \\psi_1 \\right\\}\\).\n\n\nFor the neutral electron with 2 electrons, the Hamiltonian is:\n\\[\nH(r_1,r_2) = -\\frac{\\nabla^2}{2} - \\frac{\\nabla^2}{2} - \\frac{2}{\\|r_1\\|} - \\frac{2}{\\|r_2\\|} + \\frac{1}{\\|r_1 - r_2 \\|}  \n\\] and a general two-electron Slater-determinant is written as\n\\[\n\\det\\left(\\phi_k,\\phi_l\\right) = \\frac{1}{\\sqrt{2}} \\left( \\phi_k(r_1) \\phi_l(r_2) - \\phi_l(r_1) \\phi_k(r_2) \\right).\n\\]\nAll possible Slater-determinants in the given basis:\n\nclosed-shell singlets (both electrons in the same spatial orbital):\n\\[\n\\det\\left(\\phi_0 \\phi_1 \\right) = \\frac{1}{\\sqrt{2}}\\psi_0(r_1) \\psi_0(r_1) \\otimes \\left( \\lvert \\downarrow \\uparrow \\rangle - \\lvert \\uparrow \\downarrow \\rangle \\right)\n\\] \\[\n\\det\\left(\\phi_3 \\phi_4\\right) = \\frac{1}{\\sqrt{2}}\\psi_1(r_1) \\psi_1(r_1) \\otimes \\left( \\lvert \\downarrow \\uparrow \\rangle - \\lvert \\uparrow \\downarrow \\rangle \\right)\n\\]\nopen-shell polarized triplets:\n\\[\n\\det\\left(\\phi_1 \\phi_3\\right) = \\left(\\psi_0(r_1) \\psi_1(r_2) + \\psi_1(r_1) \\psi_0(r_2)\\right) \\otimes \\left( \\lvert \\uparrow \\uparrow \\rangle  \\right)\n\\]\n\n\\[\n\\det\\left(\\phi_2 \\phi_4\\right) = \\left(\\psi_0(r_1) \\psi_1(r_2) + \\psi_1(r_1) \\psi_0(r_2)\\right) \\otimes \\left( \\lvert \\downarrow \\downarrow \\rangle  \\right)\n\\]\n\nopen-shell (with broken spin symmetry - recombinable into non-polarized triplet state and one additional singlet state):\n\\[\n\\det\\left(\\phi_0\\phi_2\\right) = \\frac{1}{\\sqrt{2}}\\left(\\phi_0(x_1) \\phi_2(x_2) - \\phi_2(x_1) \\phi_0(x2) \\right)\n\\] \\[\n\\det\\left(\\phi_1\\phi_3\\right) = \\frac{1}{\\sqrt{2}}\\left(\\phi_1(x_1) \\phi_3(x_2) - \\phi_3(x_1) \\phi_1(x2) \\right)\n\\]\n\nA general two-electron wavefunction can then be written as a linear combination of those 6 Determinants (note however, that the different spin-symmetries, i.e. the triplet and the two singlets, usually don’t mix) \\[\n\\Psi(x_1,x_2) = \\sum_{i<j\\in\\left\\{0,1\\right\\}} d_{ij} \\det\\left(\\phi_i\\phi_j\\right)\n\\] Note how this always denotes a two-electron wavefunction. The electron number directly enters the definition of the first quantized Hamiltonian and therefore defines the space onto which the Hamiltonian acts.\nFor numerical procedures it is often necessary to directly express the Hamiltonian in the given basis. Here this would mean to compute all matrix elements \\[\nH_{ij} = \\langle \\det\\left(\\phi_m\\phi_n\\right)\\rvert H \\lvert \\det\\left(\\phi_k\\phi_l\\right) \\rangle.\n\\] In this two electron example this is no problem, the task of computing all matrix elements will however become unfeasible with growing electron number due to the growth of possible determinants. Explicit computation of the Hamiltonian in the given basis is usually only performed within further approximations - e.g. truncated configuration interaction methods that only include slater determinants that differ in a specific number of orbitals from a given reference determinant.\n\n\n\nIn second quantization it is sufficient to compute the one- and two-body integrals given above to define the Hamiltonian. They grow with the fourth power of the basis size rendering the task always feasible.\nA general wavefunction can be constructed from all possible linear combinations of electronic configurations in the given spin-orbital basis - denoted by so called occupation vectors representing which spin orbitals are occupied and not. In this case we have 4 spin orbitals then therefore \\(2^4=16\\) different configurations:\n\nvacuum\n\\[\\langle 0000 \\rangle\\]\nsingle electron\n\\[\n\\lvert 1000 \\rangle, \\vert 0100 \\rangle, \\lvert 0010 \\rangle, \\lvert 0001\\rangle,\n\\]\ntwo electrons\n\\[\n\\lvert 1100 \\rangle, \\lvert 0011 \\rangle, \\lvert 1001 \\rangle, \\lvert 0110 \\rangle, \\lvert 1010\\rangle, \\lvert 0101 \\rangle,\n\\]\nthree electrons\n\\[\n\\lvert 1110 \\rangle, \\lvert 1101 \\rangle, \\lvert 1011 \\rangle, \\lvert 0111 \\rangle,\n\\]\nfour-electrons\n\\[\n\\lvert 1111 \\rangle.\n\\]\n\nA general wavefunction is then given by\n\\[\\lvert \\Psi \\rangle = \\sum_{k=0}^{16} c_k \\lvert \\text{binary}(k) \\rangle.\\]"
  },
  {
    "objectID": "tequila.html",
    "href": "tequila.html",
    "title": "jsk",
    "section": "",
    "text": "tequila\n\n\n\n\n\nTequila is an abstraction framework for (variational) quantum algorithms. It operates on abstract data structures allowing the formulation, combination, automatic differentiation and optimization of generalized objectives. Tequila can execute the underlying quantum expectation values on state of the art simulators as well as on real quantum devices.\nThis blog, contains some hands-on examples using tequila. A good starting point is here.\nApart from that, you can find more information here:\n\nrelease article\n\ntequila in a nutshell\n\na collection of presentations\n\na collection of tutorial notebooks\n\nmain code repository\n\n\n\nContribute\nTequila is free an open source. You’re welcome to contribute if you have ideas to improve the library.\nThe standard way to contribute is via pull-requests or issues on github. For larger projects it might be useful to let me know in advance what you are planning.\n\n\nInfluences\nThe design of tequilas API was inspired by madness. Angostic backend handeling and forcing differetiability was inspired by pennylane."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Jakob Kottmann",
    "section": "",
    "text": "I’m a TT Professor at the University of Augsburg’s computer science department. My research interests are in quantum algorithms, quantum chemistry and scientific computing.\nPreviously I was a postdoctoral fellow at the University of Toronto, where I was part of the matter lab leading the development of the tequila library. I did my PhD with Florian Bischoff working on multiresolution quantum chemistry with madness.\nSee posts in the blog for some hands-on code examples."
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "blog",
    "section": "",
    "text": "Molecular Quantum Circuits in a Nutshell\n\n\n\n\n\n\n\ntequila\n\n\ncode\n\n\nchemistry\n\n\n\n\n\n\n\n\n\n\n\nMar 7, 2025\n\n\nJakob Kottmann\n\n\n\n\n\n\n  \n\n\n\n\nWhat is Multiresolution Analysis\n\n\n\n\n\n\n\nmra\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nDec 1, 2022\n\n\nJakob Kottmann\n\n\n\n\n\n\n  \n\n\n\n\nElectronic Hamiltonians\n\n\n\n\n\n\n\nchemistry\n\n\n\n\n\n\n\n\n\n\n\nNov 10, 2022\n\n\nJakob Kottmann\n\n\n\n\n\n\n  \n\n\n\n\nTequila Basics: Circuits\n\n\n\n\n\n\n\ntequila\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nNov 4, 2022\n\n\nJakob Kottmann\n\n\n\n\n\n\n  \n\n\n\n\nTequila Basics: Getting Started\n\n\n\n\n\n\n\ntequila\n\n\ncode\n\n\n\n\n\n\n\n\n\n\n\nNov 3, 2022\n\n\nJakob Kottmann\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHello Quarto World\n\n\n\n\n\n\n\n\n\n\n\n\nNov 1, 2022\n\n\nJakob Kottmann\n\n\n\n\n\n\nNo matching items"
  }
]